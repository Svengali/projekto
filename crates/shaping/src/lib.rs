use bevy_log::trace;
use bevy_math::{IVec3, Vec3};
use bevy_utils::HashSet;
use bracket_noise::prelude::{FastNoise, FractalType, NoiseType};
use itertools::Itertools;

use projekto_core::chunk::{ChunkKind, ChunkLight};
use projekto_core::voxel::{self, ChunkFacesOcclusion, FacesOcclusion};

use projekto_core::{
    chunk::{self, Chunk, ChunkNeighborhood},
    voxel::{VoxelFace, VoxelVertex},
    VoxWorld,
};

mod faces_merger;
mod light_propagator;
mod light_smoother;

/*
     v3               v2
        +-----------+
  v7  / |      v6 / |
    +-----------+   |
    |   |       |   |
    |   +-------|---+
    | /  v0     | /  v1
    +-----------+
   v4           v5

   Y
   |
   +---X
  /
Z
*/

pub const VERTICES: [[f32; 3]; 8] = [
    [0.0, 0.0, 0.0], //v0
    [1.0, 0.0, 0.0], //v1
    [1.0, 1.0, 0.0], //v2
    [0.0, 1.0, 0.0], //v3
    [0.0, 0.0, 1.0], //v4
    [1.0, 0.0, 1.0], //v5
    [1.0, 1.0, 1.0], //v6
    [0.0, 1.0, 1.0], //v7
];

pub const VERTICES_INDICES: [[usize; 4]; 6] = [
    [5, 1, 2, 6], //RIGHT
    [0, 4, 7, 3], //LEFT
    [7, 6, 2, 3], //UP
    [0, 1, 5, 4], //DOWN
    [4, 5, 6, 7], //FRONT
    [1, 0, 3, 2], //BACK
];

/**
 Computes indices of a triangle list mesh.

 This function assumes 4 vertices per face, 3 indices per triangles and all vertices are placed in CCW order.

 It generates indices in the following order: _*0 1 2 2 3 0*_ where 0 is the first vertice and 3 is the last one

 **Returns** a list of indices in the CCW order
*/
pub fn compute_indices(vertex_count: usize) -> Vec<u32> {
    // Each 4 vertex is a voxel face and each voxel face has 6 indices, so we can multiply the vertex count by 1.5
    let index_count = (vertex_count as f32 * 1.5) as usize;

    let mut res = vec![0; index_count];
    let mut i = 0u32;

    while i < vertex_count as u32 {
        res.push(i);
        res.push(i + 1);
        res.push(i + 2);

        res.push(i + 2);
        res.push(i + 3);
        res.push(i);

        i += 4;
    }

    res
}

/**
 Generates a new chunk filling it with [`ChunkKind`] randomly generated by seeded noise
*/
pub fn generate_chunk(local: IVec3) -> Chunk {
    let mut noise = FastNoise::seeded(15);
    noise.set_noise_type(NoiseType::SimplexFractal);
    noise.set_frequency(0.03);
    noise.set_fractal_type(FractalType::FBM);
    noise.set_fractal_octaves(3);
    noise.set_fractal_gain(0.9);
    noise.set_fractal_lacunarity(0.5);
    let world = chunk::to_world(local);

    let mut kinds = ChunkKind::default();
    let mut lights = ChunkLight::default();

    for x in 0..chunk::X_AXIS_SIZE {
        for z in 0..chunk::Z_AXIS_SIZE {
            lights.set(
                (x as i32, chunk::Y_END, z as i32).into(),
                voxel::Light::natural(voxel::Light::MAX_NATURAL_INTENSITY),
            );

            let h = noise.get_noise(world.x + x as f32, world.z + z as f32);
            let world_height = ((h + 1.0) / 2.0) * (chunk::X_AXIS_SIZE * 2) as f32;

            let height_local = world_height - world.y;

            if height_local < f32::EPSILON {
                continue;
            }

            let end = usize::min(height_local as usize, chunk::Y_AXIS_SIZE);

            for y in 0..end {
                // TODO: Check this following biome settings
                let kind = voxel::Kind::get_kind_with_height_source(end - 1, y);

                kinds.set((x as i32, y as i32, z as i32).into(), kind);
            }
        }
    }

    Chunk {
        kinds,
        lights,
        ..Default::default()
    }
}

/**
 Compute chunk internal data like light, occlusion and vertices.

 This function should be called when a new chunk is generated.

 **Returns** a list of chunks which chunk was computed.
*/
pub fn compute_chunks_internals(world: &mut VoxWorld, locals: Vec<IVec3>) -> Vec<IVec3> {
    // Keeps only existing chunks
    let locals = locals
        .into_iter()
        .filter(|&l| world.exists(l))
        .collect_vec();

    trace!("Computing {} chunks internals", locals.len());

    update_kind_neighborhoods(world, locals.iter());
    light_propagator::propagate_natural_light_on_new_chunk(world, &locals);

    generate_internals(world, locals.iter());

    locals
}

/**
 Recompute chunk kind neighborhood and vertices.

 This function should be called whenever the chunk has changed and needs to update it's internal state.

 **Returns** a list of chunks which was recomputed.
*/
pub fn recompute_chunks_internals(
    world: &mut VoxWorld,
    update: &[(IVec3, Vec<(IVec3, voxel::Kind)>)],
) -> Vec<IVec3> {
    // Keeps only existing chunks
    let valid_update = update
        .iter()
        .cloned()
        .filter(|(l, _)| world.exists(*l))
        .collect::<Vec<_>>();

    // Extract a list with only the chunk locals
    let mut locals = valid_update.iter().map(|(l, _)| *l).collect::<HashSet<_>>();
    update_kind_neighborhoods(world, locals.iter());

    locals.extend(light_propagator::update_light(world, &valid_update));

    generate_internals(world, locals.iter());

    locals.into_iter().collect()
}

fn generate_internals<'a>(world: &mut VoxWorld, locals: impl Iterator<Item = &'a IVec3>) {
    trace!("Generating internals",);

    let occlusions = locals
        .map(|&l| (l, world.get(l).unwrap()))
        .map(|(l, chunk)| (l, faces_occlusion(chunk)))
        .map(|(l, occ)| (l, light_smoother::smooth_lighting(world, l, &occ), occ))
        .collect_vec();

    trace!(
        "Faces occlusion and light smoothing completed on {} chunks",
        occlusions.len()
    );

    for (local, smooth_light, occlusion) in occlusions {
        let chunk = world.get_mut(local).unwrap();
        if occlusion.is_fully_occluded() {
            chunk.vertices = vec![];
        } else {
            let faces = faces_merger::merge(occlusion, smooth_light, chunk);
            chunk.vertices = generate_vertices(faces);
        }
    }
}

/**
Computes the faces occlusion data of the given [`ChunkKind`]

**Returns** computed [`ChunkFacesOcclusion`]
*/
fn faces_occlusion(chunk: &Chunk) -> ChunkFacesOcclusion {
    let kinds = &chunk.kinds;

    let mut occlusion = ChunkFacesOcclusion::default();
    for voxel in chunk::voxels() {
        let mut voxel_faces = FacesOcclusion::default();

        if kinds.get(voxel).is_none() {
            voxel_faces.set_all(true);
        } else {
            for side in voxel::SIDES {
                let dir = side.dir();
                let neighbor_pos = voxel + dir;

                if let Some(neighbor_kind) = kinds.get_absolute(neighbor_pos) {
                    voxel_faces.set(side, !neighbor_kind.is_none());
                }
            }
        }

        occlusion.set(voxel, voxel_faces);
    }

    occlusion
}

/**
Generates vertices data from a given [`VoxelFace`] list.

All generated indices will be relative to a triangle list.

**Returns** a list of generated [`VoxelVertex`].
*/
fn generate_vertices(faces: Vec<VoxelFace>) -> Vec<VoxelVertex> {
    let mut vertices = vec![];
    let kinds_descs = voxel::KindsDescs::get();
    let tile_texture_size = 1.0 / kinds_descs.count_tiles() as f32;

    for face in faces {
        let normal = face.side.normal();

        let face_desc = kinds_descs.get_face_desc(&face);
        let tile_coord_start = face_desc.offset.as_vec2() * tile_texture_size;

        let faces_vertices = face
            .vertices
            .iter()
            .enumerate()
            .map(|(i, v)| {
                let base_vertex_idx = VERTICES_INDICES[face.side as usize][i];
                let base_vertex: Vec3 = VERTICES[base_vertex_idx].into();

                base_vertex + v.as_vec3()
            })
            .collect::<Vec<_>>();

        debug_assert!(
            faces_vertices.len() == 4,
            "Each face should have 4 vertices"
        );

        fn calc_tile_size(min: Vec3, max: Vec3) -> f32 {
            (min.x - max.x).abs() + (min.y - max.y).abs() + (min.z - max.z).abs()
        }

        let x_tile = calc_tile_size(faces_vertices[0], faces_vertices[1]) * tile_texture_size;
        let y_tile = calc_tile_size(faces_vertices[0], faces_vertices[3]) * tile_texture_size;

        let tile_uv = [
            (0.0, y_tile).into(),
            (x_tile, y_tile).into(),
            (x_tile, 0.0).into(),
            (0.0, 0.0).into(),
        ];

        let light_fraction = 1.0 / voxel::Light::MAX_NATURAL_INTENSITY as f32;

        for (i, v) in faces_vertices.into_iter().enumerate() {
            vertices.push(VoxelVertex {
                position: v,
                normal,
                uv: tile_uv[i],
                tile_coord_start,
                light: Vec3::splat(face.light[i] * light_fraction),
            });
        }
    }

    debug_assert!(!vertices.is_empty());
    vertices
}

/**
Updates the [`ChunkNeighborhood`] of a given locals given.
This function assumes all given chunks exists into the world and updates any neighborhood data needed by chunk.

**Panics** if a given chunk local doesn't exists
*/
fn update_kind_neighborhoods<'a>(world: &mut VoxWorld, locals: impl Iterator<Item = &'a IVec3>) {
    for &local in locals {
        let mut neighborhood = ChunkNeighborhood::default();
        for side in voxel::SIDES {
            let dir = side.dir();
            let neighbor = local + dir;

            if let Some(neighbor_chunk) = world.get(neighbor) {
                neighborhood.set(side, &neighbor_chunk.kinds);
            }
        }

        let chunk = world.get_mut(local).unwrap();
        chunk.kinds.neighborhood = neighborhood;
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn generate_chunk() {
        let local = (5432, 0, 5555).into();
        let chunk = super::generate_chunk(local);

        assert!(
            !chunk.kinds.is_default(),
            "Generate chunk should should not be default"
        );
    }

    #[test]
    fn faces_occlusion_occlude_empty_chunk() {
        // Arrange
        let chunk = Chunk::default();

        // Act
        let occlusions = super::faces_occlusion(&chunk);

        // Assert
        assert!(
            occlusions.iter().all(|a| a.is_fully_occluded()),
            "A chunk full of empty-kind voxels should be fully occluded"
        );
    }

    #[test]
    fn faces_occlusion() {
        // Arrange
        let mut chunk = Chunk::default();

        // Top-Bottom occlusion
        chunk.kinds.set((1, 1, 1).into(), 1.into());
        chunk.kinds.set((1, 2, 1).into(), 1.into());

        // Full occluded voxel at (10, 10, 10)
        chunk.kinds.set((10, 10, 10).into(), 1.into());
        chunk.kinds.set((9, 10, 10).into(), 1.into());
        chunk.kinds.set((11, 10, 10).into(), 1.into());
        chunk.kinds.set((10, 9, 10).into(), 1.into());
        chunk.kinds.set((10, 11, 10).into(), 1.into());
        chunk.kinds.set((10, 10, 9).into(), 1.into());
        chunk.kinds.set((10, 10, 11).into(), 1.into());

        // Act
        let faces_occlusion = super::faces_occlusion(&chunk);

        // Assert
        let faces = faces_occlusion.get((1, 2, 1).into());

        assert_eq!(
            faces,
            [false, false, false, true, false, false].into(),
            "Only down face should be occluded by the bottom voxel"
        );

        let faces = faces_occlusion.get((1, 1, 1).into());

        assert_eq!(
            faces,
            [false, false, true, false, false, false].into(),
            "Only down face should be occluded by the bottom voxel"
        );

        let faces = faces_occlusion.get((10, 10, 10).into());

        assert_eq!(
            faces,
            [true; voxel::SIDE_COUNT].into(),
            "Voxel fully surrounded by another non-empty voxels should be fully occluded"
        );
    }

    #[test]
    fn update_kind_neighborhoods() {
        let mut world = VoxWorld::default();

        let center = (1, 1, 1).into();
        let mut chunk = Chunk::default();
        chunk.kinds.set_all(10.into());
        world.add(center, chunk);

        for side in voxel::SIDES {
            let dir = side.dir();
            let pos = center + dir;
            let mut chunk = Chunk::default();
            chunk.kinds.set_all((side as u16).into());
            world.add(pos, chunk);
        }

        super::update_kind_neighborhoods(&mut world, vec![(1, 1, 1).into()].iter());
        let chunk = world.get_mut(center).unwrap();

        for side in voxel::SIDES {
            match side {
                voxel::Side::Right => {
                    for a in 0..chunk::Y_AXIS_SIZE {
                        for b in 0..chunk::Z_AXIS_SIZE {
                            assert_eq!(
                                chunk
                                    .kinds
                                    .neighborhood
                                    .get(side, (0, a as i32, b as i32).into()),
                                Some((side as u16).into())
                            );
                        }
                    }
                }
                voxel::Side::Left => {
                    for a in 0..chunk::Y_AXIS_SIZE {
                        for b in 0..chunk::Z_AXIS_SIZE {
                            assert_eq!(
                                chunk
                                    .kinds
                                    .neighborhood
                                    .get(side, (chunk::X_END as i32, a as i32, b as i32).into()),
                                Some((side as u16).into())
                            );
                        }
                    }
                }
                voxel::Side::Up => {
                    for a in 0..chunk::X_AXIS_SIZE {
                        for b in 0..chunk::Z_AXIS_SIZE {
                            assert_eq!(
                                chunk
                                    .kinds
                                    .neighborhood
                                    .get(side, (a as i32, 0, b as i32).into()),
                                Some((side as u16).into())
                            );
                        }
                    }
                }
                voxel::Side::Down => {
                    for a in 0..chunk::X_AXIS_SIZE {
                        for b in 0..chunk::Z_AXIS_SIZE {
                            assert_eq!(
                                chunk
                                    .kinds
                                    .neighborhood
                                    .get(side, (a as i32, chunk::Y_END as i32, b as i32).into()),
                                Some((side as u16).into())
                            );
                        }
                    }
                }
                voxel::Side::Front => {
                    for a in 0..chunk::X_AXIS_SIZE {
                        for b in 0..chunk::Y_AXIS_SIZE {
                            assert_eq!(
                                chunk
                                    .kinds
                                    .neighborhood
                                    .get(side, (a as i32, b as i32, 0).into()),
                                Some((side as u16).into())
                            );
                        }
                    }
                }
                voxel::Side::Back => {
                    for a in 0..chunk::X_AXIS_SIZE {
                        for b in 0..chunk::Y_AXIS_SIZE {
                            assert_eq!(
                                chunk
                                    .kinds
                                    .neighborhood
                                    .get(side, (a as i32, b as i32, chunk::Z_END as i32).into()),
                                Some((side as u16).into())
                            );
                        }
                    }
                }
            }
        }
    }

    #[test]
    fn faces_occlusion_neighborhood() {
        let mut world = VoxWorld::default();

        let mut top = Chunk::default();
        top.kinds.set_all(2.into());

        let mut down = Chunk::default();
        down.kinds.set_all(3.into());

        let mut center = Chunk::default();
        center
            .kinds
            .set((0, chunk::Y_END as i32, 0).into(), 1.into());
        center.kinds.set((1, 0, 1).into(), 1.into());

        world.add((0, 1, 0).into(), top);
        world.add((0, 0, 0).into(), center);
        world.add((0, -1, 0).into(), down);

        super::update_kind_neighborhoods(&mut world, vec![(0, 0, 0).into()].iter());

        let center = world.get((0, 0, 0).into()).unwrap();
        let faces_occlusion = super::faces_occlusion(&center);

        let faces = faces_occlusion.get((0, chunk::Y_END as i32, 0).into());
        assert_eq!(faces, [false, false, true, false, false, false].into());

        let faces = faces_occlusion.get((1, 0, 1).into());
        assert_eq!(faces, [false, false, false, true, false, false].into());
    }

    #[test]
    fn generate_vertices() {
        // Arrange
        let side = voxel::Side::Up;

        // This face is 2 voxels wide on the -Z axis (0,0) (0,-1)
        let faces = vec![VoxelFace {
            side,
            vertices: [
                (0, 0, 0).into(),
                (0, 0, 0).into(),
                (0, 0, -1).into(),
                (0, 0, -1).into(),
            ],
            kind: 1.into(),
            ..Default::default()
        }];

        // Act
        let vertices = super::generate_vertices(faces);

        // Assert
        let normal = side.normal();
        assert_eq!(
            vertices,
            vec![
                VoxelVertex {
                    normal,
                    position: (0.0, 1.0, 1.0).into(),
                    uv: (0.0, 0.2).into(),
                    ..Default::default()
                },
                VoxelVertex {
                    normal,
                    position: (1.0, 1.0, 1.0).into(),
                    uv: (0.1, 0.2).into(),
                    ..Default::default()
                },
                VoxelVertex {
                    normal,
                    position: (1.0, 1.0, -1.0).into(),
                    uv: (0.1, 0.0).into(),
                    ..Default::default()
                },
                VoxelVertex {
                    normal,
                    position: (0.0, 1.0, -1.0).into(),
                    uv: (0.0, 0.0).into(),
                    ..Default::default()
                },
            ]
        );
    }
}
